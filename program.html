<!-- BEGIN LOADED_SRC src/synt2021/top.src.html -->
<!--
    SYNT 2019 - Seventh Workshop on Synthesis
    Design: Synchronous by TEMPLATED
    templated.co @templatedco
    Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
	<head>
		<title>SYNT 2024</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<meta name="description" content="" />
		<meta name="keywords" content="" />
		<link href='css/lato.css' rel='stylesheet' type='text/css'>
		<script src="js/jquery.min.js"></script>
		<script src="js/skel.min.js"></script>
		<script src="js/skel-panels.min.js"></script>
		<script src="js/init.js"></script>
		<noscript>
			<link rel="stylesheet" href="css/skel-noscript.css" />
			<link rel="stylesheet" href="css/style.css" />
		</noscript>
	</head>

	<body>
		<div id="wrapper">
			
			<!-- Header -->
			<div id="header">
				<div class="container"> 
					
					<!-- Logo -->
					<div id="logo">
						<h1><a href="#">SYNT 2024</a></h1>
						<span>13th Workshop on Synthesis</span>
                                   
						<span>July 22 2024 &mdash; Montreal, Canada</span>
						<span>Co-located with the <a href="http://i-cav.org/2024/">36th
                International Conference on Computer Aided Verification</a></span>
					</div>
					
					<!-- Nav -->
					<nav id="nav">
						<ul>
							<!-- <li class="active"><a href="index.html">Home</a></li> -->
							<li id="navIndex"><a href="index.html">Home</a></li>
							<li id="navProgram"><a href="program.html">Program</a></li>
	            <li id="navCfp"><a href="cfp.html">CFP</a></li>
							<li id="navCommittees"><a href="committees.html">Committees</a></li>
							<!--<li><a href="invited.html">Invited Talks</a></li>-->
							<li id="navCompetitions"><a href="competitions.html">Competitions</a></li>
						</ul>
					</nav>
				</div>
			</div>
			<!-- /Header -->

			<div id="page">
				<div class="container">
					<div class="row">
						<div class="3u">
							<section id="sidebar1">  
								<header>
									<h3>Dates</h3> 
								</header>
                  <ul class="style3">
									 <li class="first">
										<!--<p>1st Call for Papers:</br> March 18, 2021</p> -->
                    <p>Abstract Submission:</br> May 18, 2024 </p>
										<p>Author Notification:</br> June 3, 2024</p>
										<!--<p>Camera-ready Version:</br> May 25, 2019</p> -->
										<p>Workshop:</br> July 22, 2024</p>          
                  </li>
                  </ul>
								<header>
									<h3>Archive</h3>
								</header>
								<ul class="style3">
                  <li class="first">
                    <p class="date"><a href="https://cgi.csc.liv.ac.uk/~sven/synt/">Past SYNT</a></p>
								  </li>
								</ul>
							</section>
						</div>
<!-- END LOADED_SRC src/synt2021/top.src.html -->

<!-- Ravi: HACK... -->
<script type="text/javascript">
document.getElementById("navProgram").classList.add("active")
</script>
						
						<div class="9u skel-cell-important">
							<section id="content" >                      
<header>
  <h3>Program</h3>

</header>


<tr class="invited">
  <td class="time"></td>
  <td class="info">
    <div style="float:left; padding-right:20px;">
      <figure class="wp-block-image aligncenter size-full is-resized"><img decoding="async" width="200" height="201" src="https://polgreen.github.io/img/profile.jpg" sizes="(max-width: 400px) 100vw, 400px" /></figure>
    </div>
    <p style="font-size:clamp(15.747px, 0.984rem + ((1vw - 3.2px) * 0.86), 24px);"><a href="https://polgreen.github.io/"><strong>Elizabeth Polgreen</strong></a> University of Edinburgh, UK</p>

    <strong>Keynote: Making the most of large language models for program synthesis (when you want correct answers)</strong><br/>
    
    <div class="abstract">
      <small>
        <p>
          <strong>Abstract. </strong>
          Since the release of ChatGPT, large language models (LLMs) have been dominating the discourse around code generation. In contrast, the best-performing solvers in the world of formal program synthesis are still based around enumerative algorithms. So, are we behind the times? Are LLMs the answer to all our synthesis problems? In this talk, I will present two approaches to making the most of LLMs in formal domains.
          First, I will present a technique based on combining enumerative program synthesis with guidance from an LLM [1]. Focusing on the Syntax-Guided Synthesis (SyGuS) competition benchmarks, we found that, whilst LLMs can produce syntactically correct SyGuS expressions, they fail to produce semantically correct solutions for more than half of the benchmarks. We propose a novel enumerative synthesis algorithm, which integrates calls to an LLM into a weighted probabilistic search, allowing 2-way exchange of information between the two components, and increasing the number of benchmarks solved to 80% (and outperforming the state-of-the-art solver).
          Second, I will discuss our work using LLMs to generate models of systems for verification [2]. Here, we enable LLMs to generate syntactically correct code, even in programming languages that barely feature in the training data, by combining an HCI technique called natural program elicitation and a Max-SMT solver. We apply our approach to generating models of systems in the UCLID5 verification language, improving syntactic correctness from <10% to >80% on a set of textbook problems. 
          Whilst I don’t believe LLMs are the answer to all our synthesis problems, I think our results demonstrate that perhaps techniques used in formal synthesis could be the answer to many of the problems facing LLMs..!
          <p>[1] Guiding Enumerative Program Synthesis with Large Language Models
          Yixuan Li, Julian Parsert, Elizabeth Polgreen
          </p>
          <p>
          [2] Synthetic Programming Elicitation and Repair for Text-to-Code in Very Low-Resource Programming Languages - Federico Mora, Justin Wong, Haley Lepe, Sahil Bhatia, Karim Elmaaroufi, George Varghese, Joseph E. Gonzalez, Elizabeth Polgreen, Sanjit A. Seshia       
         </p>
        </p>
      </small>
    </div>
    <!-- <button class="collapsible">Bio</button> -->
    
    <div class="bio">
      <small>
        <p>
          <strong>Bio. </strong>
          Dr Elizabeth Polgreen is a lecturer (~Assistant Professor in US terminology) in the School of Informatics at the University of Edinburgh. Prior to this, she was a postdoctoral research scholar in Professor Sanjit Seshia’s group at the University of California, Berkeley, and completed a PhD at the University of Oxford, supervised by Professor Alessandro Abate. 
          She is interested in formal program synthesis techniques, combinations of formal program synthesis and machine learning driven synthesis, and the use of synthesis to increase the scalability of verification. She currently holds a research fellowship from the Royal Academy of Engineering.        </p>
      </small>
    </div>
    <div style="float:left; padding-right:20px;">
      <figure class="wp-block-image aligncenter size-full is-resized"><img decoding="async" width="200" height="201" src="images/anshutosh.jpg" sizes="(max-width: 400px) 100vw, 400px" /></figure>
    </div>
    <p style="font-size:clamp(15.747px, 0.984rem + ((1vw - 3.2px) * 0.86), 24px);"><a href="https://astrivedi.github.io/www/index.html"><strong>Ashutosh Trivedi</strong></a> University of Colorado, Boulder</p>

    <strong>Keynote: Expanding Horizons: Hyperproperties in CPS, Fairness, and Legal Compliance Requirements</strong><br/>
    
    
    <div class="abstract">
      <small>
        <p>
          <strong>Abstract. </strong>
          In recent years, the study of hyperproperties has provided profound insights into complex system behaviors, yet many practical fields remain unexplored territories for these concepts. This talk aims to highlight the connection between hyperproperty research and real-world applications, drawing from my work in related domains such as cyber-physical systems (CPS), software fairness, legal compliance, and metamorphic testing. I will illustrate how concepts developed for hyperproperties can be effectively applied to ensure system confidentiality, equitable outcomes, regulatory adherence, and robust software testing. By exploring these practical settings, I hope to invite formal methods researchers to venture into new areas, offering fresh challenges and groundbreaking possibilities for the application of their innovative research. Join me as we discuss these diverse fields, uncovering the potential for hyperproperties to revolutionize approaches and solutions across various disciplines.
        </p>
      </small>
    </div>
    <!-- <button class="collapsible">Bio</button> -->
    
    <div class="bio">
      <small>
        <p>
          <strong>Bio. </strong>
          Ashutosh Trivedi is an Associate Professor of Computer Science at the University of Colorado Boulder, specializing in the development and application of formal methods for the design and analysis of safety-critical learning-enabled systems. He obtained his doctoral degree in computer science from the University of Warwick, with a specialization in game theory and optimization. Prior to his current position, Ashutosh served as an Assistant Professor of Computer Science at the Indian Institute of Technology Bombay. He also worked as a Postdoctoral Research Associate at the University of Pennsylvania and the University of Oxford. Ashutosh is a recipient of the 2022 NSF CAREER award and a Liverpool Fellowship. His research interests lie at the intersection of computer science, control theory, and machine learning, with a focus on formal methods and reinforcement learning.
        </p>
      </small>
    </div>
  </td>
</tr>

<!-- <strong> We are still looking for more presentations at SYNT'2024! Please contact us if you are interested. </strong>  -->
<table border="0" class="program">
  <script type="text/javascript">
    document.getElementById("navProgram").classList.add("active")
    </script>
                
                <div class="9u skel-cell-important">
                  <section id="content" >                      
  <!-- <tr class="break">
    <td class="time" style="text-align: center;">PT (UTC-7)</td>
    <td></td>
  </tr> -->


  <!-- <tr class="talk">
    <td class="time">8:00-8:05</td>
    <td class="info">
      Welcome 
    </td>
  </tr> -->

  <tr class="talk">
    <td width="150" class="time">09:00-10:00</td>
    <td class="info">
      <strong>Keynote: Making the most of large language models for program synthesis (when you want correct answers) </strong><br/>
      <a href="https://polgreen.github.io/">Elizabeth Polgreen</a> (University of Edinburgh)<br/>
      <!-- <button class="collapsible">Abstract</button> -->
      <!-- <div class="abstract">
        <small>
          <p>
            TBA
          </p>
        </small>
      </div> -->
    </td>
  </tr>

  <tr class="talk">
    <td class="time">10:00-10:15</td>
    <td class="info">
      <strong>Coffee Break </strong><br/>
    </td>
  </tr>

  <tr class="talk">
    <td class="time">10:10-10:45</td>

    <td class="info">
      <strong>Can LLMs Perform Verified Lifting of Code?</strong><br/>
      <a href=""></a>Sahil Bhatia, Jie Qiu, Niranjan Hasabnis, Sanjit Seshia and Alvin Cheung<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
            Domain-specific languages (DSLs) have become integral to various software workflows. Such languages offer domain-specific optimizations and abstractions that improve code readability and maintainability. However, leveraging these languages requires developers to rewrite existing code using the specific DSL's API. While large language models (LLMs) have shown some success in automatic code transpilation, none of them provide any functional correctness guarantees on the rewritten code. Another approach for automating this task is verified lifting, which relies on program synthesis to find programs in the target language that are functionally equivalent to the source language program. While several verified lifting tools have been developed for various application domains, they are specialized for specific source-target languages or require significant expertise in domain knowledge to make the search efficient. In this paper, leveraging recent advances in LLMs, we propose an LLM-based approach to building verified lifting tools. We use the LLM's capabilities to reason about programs to translate a given program into its corresponding equivalent in the target language. Additionally, we use LLMs to generate proofs for functional equivalence. We develop lifting-based compilers for three DSLs targeting different application domains. Our approach outperforms previous symbolic-based tools in the number of benchmarks transpiled and also requires significantly less efforts to build.
          </p>
        </small>
      </div>
    </td>
  </tr>

  <tr class="talk">
    <td class="time">10:45-11:15</td>
    <td class="info">
      <strong>Reactive Synthesis Modulo Theories with Data Temporal Relations (Extended Abstract)</strong><br/>
      <a href=""></a>Andoni Rodriguez, César Sánchez and Felipe Gorostiaga<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
            Recently, the realizability problem of LTL Modulo Theories ($\LTLt$) specifications has been shown to be decidable whenever theories are decidable.

However, such approaches suffer from a key limitation: memory of specifications is restricted.
They allow to carry finite information of infinite theories.
For instance, we can remember that "x" was odd in previous timesteps,
but we cannot remember the concrete value of "x" in previous timesteps.

This limits the ability of abstractions to properly encode richer dynamics in the specifications
(e.g., it is currently not possible to specify that a variable increases monotonically over time).

In this paper, we extend $\LTLt$ with operators that allow to fetch values of the variables in previous instants ($\LTLtf$).
We show that realizability in $\LTLtf$ is undecidable in general,
but we also propose a sound incomplete algorithm that works for expressive $\LTLtf$ formulae in which we can specify realistic environment dynamics.

In addition, we present a novel procedure that abstracts tautologies in $\LTLtf$ to tautologies in $\LTLt$,
which conveys memory across-time and thus helps pushing conclusiveness of our algorithm.

Moreover, we show that we can encode inductive behaviour such as counters and averages.

To the best of our knowledge, this is the first work that presents sound realizability algorithms that conclude in such expressive specifications.
          </p>
        </small>
      </div>
    </td>
  </tr>

  <tr class="talk">
    <td class="time">11:15-11:45</td>
    <td class="info">
      <strong>Synthesizing Exact Loop Bounds</strong><br/>
      <a href=""></a>Daniel Riley and Grigory Fedyukovich<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
            Many state-of-the-art techniques are designed to automatically
            infer upper limits on the number of iterations a loop may execute, conventionally
            called bounds. Analysis of this kind is inspired by techniques to prove
            termination used in previous works, namely to instrument the program
            with a decrementing counter and find the conditions by which the counter’s
            value is above zero at the end of the program. However, in most cases, they do
            not capture the exact number of iterations which could be useful to estimate
            the number of cycles/iterations/time a process requires when it is distributed
            across many devices, relational verification and equivalence checking,
            and even non-termination. In this extended abstract, we present the ongoing
            work on synthesis of an exact loop bound for single-loop programs as a function
            over the program’s inputs.
          </p>
        </small>
      </div>
    </td>
  </tr>

  <tr class="talk">
    <td class="time">11:45-14:00</td>
    <td class="info">
      <strong>Lunch </strong><br/>
    </td>
  </tr>


  <tr class="talk">
    <td class="time">14:00-15:00</td>
    <td class="info">
      <strong>Keynote: Expanding Horizons: Hyperproperties in CPS, Fairness, and Legal Compliance Requirements </strong><br/>
      <a href="https://astrivedi.github.io/www/index.html">Ashutosh Trivedi</a> (University of Colorado, Boulder)<br/>
      <!-- <button class="collapsible">Abstract</button> -->
      <!-- <div class="abstract">
        <small>
          <p>
            TBA
          </p>
        </small>
      </div> -->
    </td>
  </tr>

  <tr class="talk">
    <td class="time">15:00-15:15</td>
    <td class="info">
      <strong>Coffee Break </strong><br/>
    </td>
  </tr>

  <tr class="talk">
    <td class="time">15:15-15:45</td>

    <td class="info">
      <strong>ZDD Boolean Synthesis </strong><br/>
      <a href=""></a>Yi Lin, Lucas M. Tabajara, Moshe Y. Vardi<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
            Motivated by applications in boolean-circuit design, boolean
            synthesis is the process of synthesizing a boolean function with multiple outputs, given a relation between its inputs and outputs. Previous
            work has attempted to solve boolean functional synthesis by converting a
            specification formula into a Binary Decision Diagram (BDD) and quantifying existentially the output variables. We make use of the fact that
            the specification is usually given in the form of a Conjunctive Normal
            Form (CNF) formula, and we can perform resolution on a symbolic representation of a CNF formula in the form of a Zero-suppressed Binary
            Decision Diagram (ZDD). We adapt the realizability test to the context
            of CNF and ZDD, and show that the Cross operation defined in earlier
            work can be used for witness construction. Experiments show that our
            approach is complementary to BDD-based Boolean synthesis.
          </p>
        </small>
      </div>
    </td>
  </tr>

  <tr class="talk">
    <td class="time">15:45-16:15</td>
    <td class="info">
      <strong>Synthesis of Multi-Threaded Programs</strong><br/>
      <a href=""></a>Sidi Mohamed Beillahi, Ahmed Bouajjani, Constantin Enea and Shuvendu Lahiri<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
            Asynchronous and concurrent programming are fundamental concepts for building responsive and efficient software systems. To this end, we proposed an approach for refactoring a sequential program into an asynchronous program that uses async/await, called asynchronization, without introducing data races [1]. We showed that the delay complexity of enumerating all data race free asynchronizations, which quantifies the delay between outputting two consecutive data race free asynchronizations, is polynomial time modulo an oracle for solving reachability in sequential programs. In this paper, we show that this approach and the associated results extend to refactoring a sequential program into a data race free multi-threaded program that uses start/join.
          </p>
        </small>
      </div>
    </td>
  </tr>

  <tr class="talk">
    <td class="time">16:15-16:35</td>
    <td class="info">
      <strong>SYNTCOMP results</strong><br/>
      <a href=""></a>Swen Jacobs<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
            This is the presentation of the SYNTCOMP results.
          </p>
        </small>
      </div>
    </td>
  </tr>

  <tr class="talk">
    <td class="time">16:35-16:40</td>
    <td class="info">
      <strong>Closing</strong><br/>
    </td>
  </tr>
</table>





  <!-- <tr class="session">
    <th class="header" colspan="2">Session 1</th>
    <th></th>
  </tr>

  <tr class="talk">
    <td class="time"></td>
    <td class="info"><span style="float: right;">Session Chair: Dave Parker&nbsp;&nbsp;</span></td>
  </tr>

  <tr class="talk">
    <td class="time">08:05-09:05</td>
    <td class="info">
      <strong>Keynote: Enabling Provable Security at Scale</strong><br/>
      Neha Rungta (Amazon Web Services)<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
          The cloud model can be viewed as a contract between customers and
          providers: customers program against the cloud model, and the cloud
          provider faithfully implements the model.  In this talk, we focus on
          the problem of access control. Many users are moving sensitive
          workloads to the cloud and require that their access control
          policies comply with their governance requirements and security best
          practices.  In this talk, I will present an overview of Zelkova, an
          SMT-based analysis engine, for verification of Amazon Web Services
          (AWS) access control policies that govern permissions across entire
          applications in the cloud. It uses traditional formal verification
          techniques such as language transformation and off-the-shelf SMT
          solvers. zelkova can be queried to explore the properties of
          policies e.g. whether some resource is &quot;publicly&quot; accessible, and is leveraged in features such as Amazon S3 Block Public Access, AWS Config Managed Rules, and Amazon Macie. Our experience shows that to leverage formal policy analysis users must have sufficient technical sophistication to realize the criteria important to them and be able to formalize the properties of interest as zelkova queries. In 2019, we launched a publicly available service IAM Access Analyzer that leverages Zelkova to automatically identify resources such as S3 buckets and IAM roles that are shared with an external entity. We help users understand whether their policy is correct, by abstracting the policy into a compact set of positive and declarative statements that precisely summarize who has access to a resource. Users can review the summary to decide whether the policy grants access according to their intentions.
          </p>
        </small>
      </div>
      <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/vk0v0-sgVl4';">Video
      </button> 
    </td>
  </tr>

  <tr class="talk">
    <td class="time">09:05-09:25</td>
    <td class="info">
      <span style="font-weight: bold;">DeepSynth: Automata Synthesis for Automatic Task Segmentation in Deep Reinforcement Learning</span><br/>
      Mohammadhosein Hasanbeig, Natasha Jeppu, Alessandro Abate, Tom Melham and Daniel Kroening<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
This paper proposes DeepSynth, a method for effective training of deep Reinforcement Learning (RL) agents when the reward is sparse and non-Markovian, but at the same time progress towards the reward requires achieving an unknown sequence of high-level objectives. Our method employs a novel algorithm for synthesis of compact automata to uncover this sequential structure automatically. We synthesise a human-interpretable automaton from trace data collected by exploring the environment. The state space of the environment is then enriched with the synthesised automaton so that the generation of a control policy by deep RL is guided by the discovered structure encoded in the automaton. The proposed approach is able to cope with both high-dimensional, low-level features and unknown sparse non-Markovian rewards. We have evaluated DeepSynth's performance in a set of experiments that includes the Atari game Montezuma's Revenge. Compared to existing approaches, we obtain a reduction of two orders of magnitude in the number of iterations required for policy synthesis, and also a significant improvement in scalability.
          </p>
        </small>
      </div>
      <button
        class="extended"
        onclick="window.location.href = 'https://arxiv.org/pdf/1911.10244.pdf ';">Paper
      </button>
 <!--      <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/HUPijcxpiEI';">Video
      </button>
    </td>
  </tr>
  
  <tr class="talk">
    <td class="time">09:25-09:45</td>
    <td class="info">
      <span style="font-weight: bold;">Automatic Synthesis of Experiment Designs from Probabilistic Environment Specifications</span><br/>
      Craig Innes, Yordan Hristov, Georg Kamaras, Subramanian Ramamoorthy<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
This paper presents an extension to the probabilistic programming language ProbRobScene, allowing users to automatically synthesize uniform experiment designs directly from environment specifications. We demonstrate its effectiveness on a number of environment specification snippets from tabletop manipulation, and show that our method generates reliably low-discrepancy designs.
          </p>
        </small>
      </div>
<!--       <button
        class="extended"
        onclick="window.location.href = 'https://arxiv.org/abs/2007.06760';">Extended Abstract
      </button>
      <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/UK2Z8xnq8r8';">Video
      </button> 
    </td>
  </tr>
  
  <tr class="talk">
    <td class="time">09:45-10:00</td>
    <td class="info">Break<br/>&nbsp;</td>
  </tr>

  <tr class="session">
    <th class="header" colspan="2">Session 2</th>
    <th></th>
  </tr>
  
  <tr class="talk">
    <td class="time"></td>
    <td class="info"><span style="float: right;">Session Chair: Suguman Bansal &nbsp;&nbsp;</span></td>
  </tr>

  <tr class="talk">
    <td class="time">10:00-10:40</td>
    <td class="info">
      <span style="font-weight: bold;">Invited talk: Gamed-Based Predictive Runtime Monitoring</span><br/>
      Sriram Sankaranarayanan (Colorado)<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
In this talk, we will present some recent results on predictive
runtime monitoring approaches for cyber-physical systems using games.
Runtime monitors check whether a system under deployment adheres to
key temporal logic specifications. In the context of "autonomous" cyber-physical
systems these include safety properties such as maintaining a minimum
separation (collision avoidance), maintaining velocities within some
safe bounds,
or remaining inside a specific geographic region (geofencing). However,
runtime monitoring of safety properties often requires predicting
whether a safety property will be violated in a sufficiently long
future time horizon
to mitigate against the risk of an  impending violation.

In the talk, we will describe viability monitoring that checks whether
the controller
has a strategy to maintain a given safety property over a given future
time horizon. Such a monitor
naturally leads to a stochastic safety game played between the
controller and an unknown stochastic
environment. We present a fast approach to viability monitoring for
the special case of linear stochastic
systems. We will also discuss the potential advantages and
disadvantages of viability monitoring.
Moving beyond simple linear systems, we present some ongoing work on
viability monitoring for
cyber-physical systems with human operators that involve added
complexities such as
nonlinear vehicle models and  complex safety properties.
          </p></small>
      </div>
    </td>
  </tr>

        <tr class="talk">
    <td class="time">10:40-10:55</td>
    <td class="info">
      <span style="font-weight: bold;">SYNTCOMP results</span><br/>
      Guillermo A. P&eacute;rez<br/>
<!--       <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
We study the problem of learning control policies for complex tasks given by logical specifications
Typically, these approaches automatically generate a reward function from a given specification and use a suitable reinforcement learning algorithm to learn a policy that maximizes the expected reward. These approaches, however, scale poorly to complex tasks that require high-level planning.
In this work, we develop a compositional learning approach, called \dirl, that leverages the specification to decompose the task into a high-level planning problem and a set of simpler reinforcement learning tasks.
An evaluation of \dirl on a challenging control benchmark with continuous state and action spaces demonstrates that it outperforms state-of-the-art baselines.
          </p>
        </small>
      </div> -->
<!--       <button
        class="extended"
        onclick="window.location.href = 'papers/Modular_Synthesis_of_Reactive_Programs.pdf';">Extended Abstract
      </button>
      <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/RquAVgC0sEA';">Video
      </button> 
    </td>
  </tr>

  <tr class="talk">
    <td class="time">10:55-11:10</td>
    <td class="info">
      <span style="font-weight: bold;">Modernising Strix</span><br/>
      Philipp Meyer and Salomon Sickert<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
We describe the architectural changes applied to Strix, a tool for LTL reactive synthesis, that were made in preparation for SYNTCOMP 2021. We replace the specialised translation from linear temporal logic (LTL) to deterministic parity automata (DPW) (as described in [8]) by a simpler and more general translation based on the recent ∆2-normalisation for LTL by [13] and Zielonka split trees. Further, we make use of a new parity game solving algorithm by [14]. These changes simplify overall design, put the tool on a cleaner theoretical foundation, and improve the performance.
          </p>
        </small>
      </div>
<!--       <button
        class="extended"
        onclick="window.location.href = 'papers/Modular_Synthesis_of_Reactive_Programs.pdf';">Extended Abstract
      </button>
      <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/RquAVgC0sEA';">Video
      </button>
    </td>
  </tr> 
<!--
  <tr class="talk">
    <td class="time">10:55-11:10</td>
    <td class="info">
      <span style="font-weight: bold;">Modernising Strix</span><br/>
      Philipp Meyer and Salomon Sickert<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
We describe the architectural changes applied to Strix, a tool for LTL reactive synthesis, that were made in preparation for SYNTCOMP 2021. We replace the specialised translation from linear temporal logic (LTL) to deterministic parity automata (DPW) (as described in [8]) by a simpler and more general translation based on the recent ∆2-normalisation for LTL by [13] and Zielonka split trees. Further, we make use of a new parity game solving algorithm by [14]. These changes simplify overall design, put the tool on a cleaner theoretical foundation, and improve the performance.
          </p>
        </small>
      </div>
      <button
        class="extended"
        onclick="window.location.href = 'papers/Modular_Synthesis_of_Reactive_Programs.pdf';">Extended Abstract
      </button>
      <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/RquAVgC0sEA';">Video
      </button> 
    </td>
  </tr>

  <tr class="talk">
    <td class="time">11:10-11:25</td>
    <td class="info">
      <span style="font-weight: bold;">Almost-Symbolic Synthesis via Delta-2-Normalisation for Linear Temporal Logic</span><br/>
      Remco Abraham, Tom van Dijk and Salomon Sickert<br/>
 <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
The classic approach to synthesis of reactive systems from linear temporal logic (LTL) specifications involves the translation of the specification to a deterministic omega-automaton and computing a winning strategy for the corresponding game with an omega-regular winning condition. Unfortunately, this procedure has an unavoidable double-exponential blow-up in the worst-case and suffers from the state-explosion problem. To address this state-explosion problem in practice we propose an almost-symbolic version of this classic idea that performs the following steps:
(1) normalisation of the specification into a Boolean combination of simple fragment of LTL,
(2) translation of each simple subformula into a deterministic automaton,
(3) encoding of each automaton into a binary decision diagram (BDD),
(4) construction of a parity automaton (and thus game) by operations on the BDD,
(5) symbolic computation of a winning strategy, and finally
(6) extraction of a symbolic controller.
We prototype this approach in the tool Otus, compare it against Strix, the winner of SYNTCOMP 2018-2020, on the SYNTCOMP benchmarks,
and identify several specifications where Otus outperforms Strix.
          </p>
        </small>
      </div>
    </td>
  </tr>

  <tr class="talk">
    <td class="time">11:25-11:40</td>
    <td class="info">
      <span style="font-weight: bold;">Acacia-Bonsai: A Modern Implementation of Downset-Based LTL Realizability</span><br/>
      Michaël Cadilhac and Guillermo Perez<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
We describe our implementation of downset-based algorithms used to solve the
realizability problem for linear temporal logic (LTL). These algorithms were
introduced by Filiot et al. in the 2010s and implemented in the tools Acacia
and Acacia+ in C and Python. We identify degrees of freedom in the original
algorithms and provide a complete rewriting of Acacia in C++20 articulated
around genericity and leveraging modern techniques for better performances.
These techniques include compile-time specialization of the algorithms, the
use of SIMD registers to store vectors, and several preprocessing steps, some
relying on efficient Binary Decision Diagram (BDD) libraries.
          </p>
        </small>
      </div>
<!--       <button
        class="extended"
        onclick="window.location.href = 'papers/Modular_Synthesis_of_Reactive_Programs.pdf';">Extended Abstract
      </button>
      <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/RquAVgC0sEA';">Video
      </button> 
    </td>
  </tr>

  <tr class="talk">
    <td class="time">11:40-11:55</td>
    <td class="info">
      <span style="font-weight: bold;">Improvements to LTLsynt</span><br/>
      Florian Renkin, Philipp Schlehuber-Caissier, Alexandre Duret-Lutz and Adrien Pommellet<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
  We summarize LTLsynt's evolution since 2018.
          </p>
        </small>
      </div>
      <button
        class="extended"
        onclick="window.location.href = 'https://eur01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fhal.archives-ouvertes.fr%2Fhal-03523385%2Ffile%2Frenkin.21.synt.pdf&amp;data=04%7C01%7CGuillermoAlberto.Perez%40uantwerpen.be%7Cd94ca9e213554ed3eaf308d9daa21b96%7C792e08fb2d544a8eaf72202548136ef6%7C0%7C0%7C637781213159219563%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000&amp;sdata=Mh7N%2BJdtB0sAaq9GDlg8V7zS9tWzrYrN%2F701ZCFxw8U%3D&amp;reserved=0';">Paper
      </button>
<!--       <button
        class="extended"
        onclick="window.location.href = 'papers/Modular_Synthesis_of_Reactive_Programs.pdf';">Extended Abstract
      </button>
      <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/RquAVgC0sEA';">Video
      </button> 
    </td>
  </tr>

  <tr class="talk">
    <td class="time">11:55-12:10</td>
    <td class="info">Break<br/>&nbsp;</td>
  </tr>

  <tr class="session">
    <th class="header" colspan="2">Session 3</th>
    <th></th>
  </tr>

  <tr class="talk">
    <td class="time"></td>
    <td class="info"><span style="float: right;">Session Chair: Sebastian Junges&nbsp;&nbsp;</span></td>
  </tr>

<tr class="talk">
    <td class="time">12:10-12:50</td>
    <td class="info">
      <span style="font-weight: bold;">Invited talk: Using Program Synthesis to Build Compilers</span><br/>
      Alvin Cheung (UC Berkeley)<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
Domain-specific languages (DSLs) are prevalent across many application
domains. Such languages let developers easily express computations using
high-level abstractions that result in performant implementations. To
leverage DSLs, however, application developers need to master the DSL’s
syntax and manually rewrite existing code. Compilers can aid in this
effort, but building them requires designing and implementing syntax
transformation rules, which is often a tedious and error-prone process.

In this talk, I will discuss how we view compilation as program
synthesis: given source code to compile, our goal is to synthesize a
program written in the target DSL that is the most performant (in terms
of execution time, etc) and is semantically equivalent to the input. As
searching for all possible programs in the target language is
intractable, I will describe verified lifting, where we first "lift" the
source code into a high-level summary that captures the semantics of the
input, and subsequently generate executable code in the target language
from the summary. Much of these two steps is driven by synthesis. I will
argue that this approach makes compilers much easier to construct and
maintain, and will illustrate verified lifting using a number of DSL
compilers we have constructed. This includes Dexter
(metalift.github.io), which translates C++ image processing codes into
the Halide DSL, with the translated code now shipping with Adobe Photoshop.

Bio:

Alvin Cheung is an assistant professor in UC Berkeley's EECS Dept. His
research focuses on designing new techniques to solve programming
systems problems. Alvin's research has been recognized through multiple
early career awards such as the US Presidential Early Career Award for
Scientists and Engineers and the Sloan Fellowship, along with a number
of best paper and demo awards, most recently with a best paper award at
CHI 2021.
          </p></small>
      </div>
<!--       <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/pNDVfkXgdic';">Video
      </button> 
    </td>
  </tr>

  <tr class="talk">
    <td class="time">12:50-13:10</td>
    <td class="info">
      <span style="font-weight: bold;">Synthesis of Compact Strategies for Coordination Programs</span><br/>
      Kedar Namjoshi and Nisarg Patel<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
 A coordination program guides the actions of independent
agents towards a desired joint behavior. Examples include controllers
for IoT devices or robot teams, and orchestrators of microservices. Coordination strategies are an attractive target for program synthesis, as
the desired behavior can be easy to specify but difficult to implement.
A practically important but often-unstated requirement is that a coordination program should not initiate unnecessary actions, which do
not contribute to meeting the specification. A strategy that satisfies this
requirement while meeting the specification is called “compact.” This
paper introduces and formalizes the notion of compactness, and demon-
strates that existing methods for program synthesis may produce non-
compact strategies. The synthesis of compact strategies is carried out
with a specification transformation which guarantees that the winning
strategies for the transformed specification are precisely the compact
strategies for the original. Following this transformation, existing syn-
thesis methods may be applied to construct compact strategies, as is
demonstrated with a prototype implementation.
          </p>
        </small>
      </div>
<!--       <button
        class="extended"
        onclick="window.location.href = 'papers/Modular_Synthesis_of_Reactive_Programs.pdf';">Extended Abstract
      </button>
      <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/RquAVgC0sEA';">Video
      </button> 
    </td>
  </tr>

    <tr class="talk">
    <td class="time">13:10-13:30</td>
    <td class="info">
      <span style="font-weight: bold;">Compositional Reinforcement Learning from Logical Specifications</span><br/>
      Kishor Jothimurugan, Suguman Bansal, Osbert Bastani and Rajeev Alur<br/>
      <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
We study the problem of learning control policies for complex tasks given by logical specifications
Typically, these approaches automatically generate a reward function from a given specification and use a suitable reinforcement learning algorithm to learn a policy that maximizes the expected reward. These approaches, however, scale poorly to complex tasks that require high-level planning.
In this work, we develop a compositional learning approach, called \dirl, that leverages the specification to decompose the task into a high-level planning problem and a set of simpler reinforcement learning tasks.
An evaluation of \dirl on a challenging control benchmark with continuous state and action spaces demonstrates that it outperforms state-of-the-art baselines.
          </p>
        </small>
      </div>
      <button
        class="extended"
        onclick="window.location.href = 'https://arxiv.org/abs/2106.13906';">Paper
      </button>
<!--       <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/RquAVgC0sEA';">Video
      </button> 
    </td>
  </tr>

      <tr class="talk">
    <td class="time">13:30-13:45</td>
    <td class="info">
      <span style="font-weight: bold;">Update on the SyGuS-IF standard</span><br/>
      Andrew Reynolds<br/>
<!--       <button class="collapsible">Abstract</button>
      <div class="abstract">
        <small>
          <p>
We study the problem of learning control policies for complex tasks given by logical specifications
Typically, these approaches automatically generate a reward function from a given specification and use a suitable reinforcement learning algorithm to learn a policy that maximizes the expected reward. These approaches, however, scale poorly to complex tasks that require high-level planning.
In this work, we develop a compositional learning approach, called \dirl, that leverages the specification to decompose the task into a high-level planning problem and a set of simpler reinforcement learning tasks.
An evaluation of \dirl on a challenging control benchmark with continuous state and action spaces demonstrates that it outperforms state-of-the-art baselines.
          </p>
        </small>
      </div> 
<!--       <button
        class="extended"
        onclick="window.location.href = 'papers/Modular_Synthesis_of_Reactive_Programs.pdf';">Extended Abstract
      </button>
      <button
        class="extended"
        onclick="window.location.href = 'https://youtu.be/RquAVgC0sEA';">Video
      </button> 
    </td>
  </tr>
  <tr class="session">
    <th class="header" colspan="2">&nbsp;</th>
    <th></th>
  </tr>

  <tr class="talk">
    <td class="time">13:45-13:50</td>
    <td class="info">
      Closing
      <br>
    </td>
  </tr>

  <tr class="session">
    <th class="header" colspan="2">&lt;/SYNT 2021&gt;</th>
    <th></th>
  </tr>

</table> 


                                                        </section>
						</div>
					</div>

				</div>	
			</div>
            -->

			<!-- Footer
			<div id="footer">
				<div class="container">
					<div class="row">
						<div class="3u">
							<section id="box1">
								<header>
									<h2>Nulla facilisi</h2>
								</header>
								<ul class="style3">
									<li class="first">
										<p class="date"><a href="#">10.03.2012</a></p>
										<p><a href="#">Vestibulum sem magna, elementum ut, vestibulum facilisis. Nulla facilisi. Cum sociis natoque penatibus.</a></p>
									</li>
									<li>
										<p class="date"><a href="#">10.03.2012</a></p>
										<p><a href="#">Pellentesque erat erat, tincidunt in, eleifend, malesuada bibendum. Suspendisse sit amet  in eros bibendum condimentum. </a> </p>
									</li>
								</ul>
							</section>
						</div>
						<div class="6u">
							<section id="box2">
								<header>
									<h2>Donec dictum metus</h2>
								</header>
								<div> <a href="#" class="image full"><img src="images/pics02.jpg" alt=""></a> </div>
								<p>Nulla enim eros, porttitor eu, tempus id, varius non, nibh. Duis enim nulla, luctus eu, dapibus lacinia, venenatis id, quam. Vestibulum imperdiet, magna nec eleifend rutrum, nunc lectus vestibulum velit, euismod lacinia quam nisl id lorem. Quisque erat. Vestibulum pellentesque, justo mollis pretium suscipit, justo nulla blandit libero, in blandit augue justo quis nisl.</p>
							</section>
						</div>
						<div class="3u">
							<section id="box3">
								<header>
									<h2>Gravida ipsum</h2>
								</header>
								<ul class="style1">
									<li class="first"><a href="#">Pellentesque quis elit non lectus eleifend purus condimentum.</a></li>
									<li><a href="#">Lorem ipsum dolort, consectetuer adipiscing dictum metus sapien.</a></li>
									<li><a href="#">Phasellus nec dictum metus in sapien pellentesque congue.</a></li>
									<li><a href="#">Cras vitae metus aliquam risus dictum metus in sapien pharetra.</a></li>
									<li><a href="#">Duis non dictum metus in sapien ante in metus commodo euismod lobortis.</a></li>
								</ul>
							</section>
						</div>
					</div>
				</div>
			</div>-->

			<!-- Copyright -->
			<div id="copyright">
				<div class="container">
					Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://pixabay.com">Pixabay</a>				</div>
			</div>
			
		</div>
	</body>

<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>

</html>

